package mappings

import "fmt"

// StepFive
/*
Внутри функции main (объявлять функцию не нужно) необходимо написать программу:
На стандартный ввод подается 10 целых чисел, разделенных пробелами (числа могут повторяться).
Для чтения из стандартного ввода импортирован пакет fmt.

Вам необходимо вычислить результат выполнения функции work для каждого из полученных чисел.
Функция work имеет следующий вид:

func work(x int) int
Результаты вычислений, разделенные пробелами, должны быть напечатаны в строку.

Однако работа функции work занимает слишком много времени.
Выделенного вам времени выполнения не хватит на последовательную обработку каждого числа,
поэтому необходимо реализовать кэширование уже готовых результатов и использовать их в работе.

После завершения работы программы результат выполнения будет дополнен информацией
о соблюдении установленного лимита времени выполнения.
*/
func StepFive() {
	var number, result int
	var cacheResult = make(map[int]int)

	for i := 0; i < 10; i++ {
		fmt.Scan(&number)

		if cache, ok := cacheResult[number]; ok {
			result = cache
		} else {
			result = work(number)
			cacheResult[number] = result
		}

		fmt.Print(result, " ")
	}
}

func work(x int) int {
	//for i := 0; i < 10000; i++ {}

	return x - 1
}

// StepSix
/*
В ходе анализа результатов переписи населения информация была сохранена в объекте типа map:

groupCity := map[int][]string{
	10:   []string{...}, // города с населением 10-99 тыс. человек
	100:  []string{...}, // города с населением 100-999 тыс. человек
	1000: []string{...}, // города с населением 1000 тыс. человек и более
}
При подготовке важного отчета о городах с населением 100-999 тыс. человек был подготовлен другой объект типа map:

cityPopulation := map[string]int{
	город: население города в тысячах человек,
}
Однако база данных с информацией о точной численности населения содержала ошибки, поэтому в cityPopulation в т.ч.
была сохранена информация о городах, которые входят в другие группы из groupCity.

Ваша программа имеет доступ к обоим указанным отображениям, требуется исправить cityPopulation,
чтобы в ней была сохранена информация только о городах из группы groupCity[100].

Функция main() уже объявлена, доступ к отображениям осуществляется по указанным именам.
По результатам выполнения ничего больше делать не требуется, проверка будет осуществлена автоматически.
*/
func StepSix() {
	groupCity := map[int][]string{
		// города с населением 10-99 тыс. человек
		10: []string{"Kantemirovka", "Serpukhov", "Sofrino"},

		// города с населением 100-999 тыс. человек
		100: []string{"Odintsovo", "Tambov", "Pushkino"},

		// города с населением 1000 тыс. человек и более
		1000: []string{"Voronezh", "Novgorod", "Tula"},
	}

	// город: население города в тысячах человек,
	cityPopulation := map[string]int{
		"Odintsovo":    280000,
		"Serpukhov":    15000,
		"Sofrino":      11500,
		"Voronezh":     3450000,
		"Tambov":       125000,
		"Kantemirovka": 12345,
		"Pushkino":     175000,
	}

	/*
	 * Группировка городов по численности населения в тысячах человек
	 * от 10 до 100, от 100 до 1000 и более 1000:
	 * groupCity map[int][]string{
	 *	 10: []string{...},
	 *	 100: []string{...},
	 *	 1000: []string{...},
	 * }
	 *
	 * Население городов в тысячах человек:
	 * cityPopulation map[string]int{...}
	 */

	fmt.Println(cityPopulation)

	for population, cities := range groupCity {
		if population == 100 {
			continue
		}

		for _, city := range cities {
			if _, ok := cityPopulation[city]; ok {
				delete(cityPopulation, city)
			}
		}
	}

	fmt.Println(cityPopulation)
}
